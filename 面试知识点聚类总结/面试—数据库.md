- ## MYSQL的A C I D怎样实现的？

  https://blog.csdn.net/ggxxkkll/article/details/7616739

  > - 原子性：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
  >
  >   > 如何保证？利用回滚日志Undo
  >
  > - 一致性：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
  >
  >   > 如何保证？通过原子性，隔离性，持久性来保证一致性
  >
  > - 隔离性：一个事务所做的修改在最终提交以前，对其它事务是不可见的。
  >
  >   > 如何保证？锁和MVCC机制
  >
  > - 持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
  >
  >   > 如何保证？利用redo日志
  >
  > - **事务操作：对user_info表执行 update user_info set name =“赵六” where id=1 整个流程如下**
  >
  >   1、修改数据前首先把需要修改的数据从数据表中读取到内存。
  >
  >   2、把原数据作为历史版本记录到undo log里。
  >
  >   3、把需要变更的数据记录到redo log里。
  >
  >   4、commit或rollback事务，修改表数据。

- ## 多事务并发问题 https://zhuanlan.zhihu.com/p/15010797

  > - 脏写：事务 B 去修改了事务 A 修改过的值，但是此时事务 A 还没提交，所以事务 A 随时会回滚，导致事务 B 修改的值也没了
  >
  > - 脏读：事务 B 去查询了事务 A 修改过的数据，但是此时事务 A 还没提交，所以事务 A 随时会回滚导致事务 B 再次查询就读不到刚才事务 A 修改的数据了。**note：无论是脏写还是脏读，都是因为一个事务去更新或者查询了另外一个还没提交的事务更新过的数据。因为另外一个事务还没提交，所以它随时可能会回滚，那么必然导致你更新的数据就没了，或者你之前查询到的数据就没了**
  >
  > - 不可重复读：
  >
  >   <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210727185439698.png" alt="image-20210727185439698" style="zoom:33%;" />
  >
  > - 幻读：幻读就是你一个事务用一样的 SQL 多次查询，结果每次查询都会发现查到一些之前没看到过的数据。注意，幻读特指的是你查询到了之前查询没看到过的数据。

- ## MYSQL的事务隔离机制/级别（4种隔离级别）

  > - 未提交读：事务中的修改，即使没有提交，对其它事务也是可见的。
  > - 提交读：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
  > - 可重复读：保证在同一个事务中多次读取同样数据的结果是一样的。
  > - 可串行化：强制事务串行执行。（需要加锁实现，而其它隔离级别通常不需要）

- ## MVCC

  > - 定义：多版本并发控制(Multi-Version Concurrency Control, MVCC)是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。
  >
  > - 原理：利用版本号来实现。
  >
  >   ```java
  >   /*
  >     系统版本号:是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
  >     事务版本号:事务开始时的系统版本号。
  >   */
  >   MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号:
  >   	1.创建版本号:指示创建或更新一个数据行的快照时的系统版本号;当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号,理解这点很关键。
  >   	2.删除版本号:指删除或更新一个数据行的快照时的系统版本号。如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。
  >     MVCC 使用到的快照存储在 Undo日志中，该日志通过回滚指针把一个数据行(Record)的所有快照连接起来。
  >   ```


- ## 数据库三大范式

  > - 第一范式:  确保每列保持原子性
  >
  >   ​	比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式
  >
  > - 第二范式:  确保表中的每列都和主键相关(拒绝联合主键)
  >
  >   ​	比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了
  >
  > - 第三范式：确保每列都和主键列直接相关,而不是间接相关（数据不能存在传递关系）
  >
  >   ​	比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。

- ## MySQL引擎对比

  > https://www.runoob.com/w3cnote/mysql-different-nnodb-myisam.html
  
- ## 数据库mysql底层：B+ Tree

  > - 一棵m阶的B-Tree有如下特性:
  >
  >   > 1. 每个节点最多有m个孩子。 
  >   > 2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
  >   > 3. 若根节点不是叶子节点，则至少有2个孩子 
  >   > 4. 所有叶子节点都在同一层，且不包含其它关键字信息 
  >   > 5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
  >   > 6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
  >   > 7. ki(i=1,…n)为关键字，且关键字升序排序。 
  >   > 8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)
  >
  > - B+ Tree 和B Tree的区别：
  >
  >   > 1. 非叶子结点的子树指针与关键字个数相同；
  >   > 2. 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）
  >   > 3. 为所有叶子结点增加一个链指针。图中Q是通过指针连在一起的。
  >   > 4. 所有关键字都在叶子结点出现。（5 8 9 10 15 18 20 26 ...等等）叶子结点相当于是存储（关键字）数据的数据层；
  >   > 5. B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中）
  >   > 6. 所有的非终端结点可以看成是索引部分，结点中的关键字是有其孩子指向的子树中最大（或最小）关键字。`比如第二层5 它的子树为5 8 9` (而B 树的非终节点也包含需要查找的有效信息)
  >
  > - 数据底层为什么要选择B+ Tree（优势）

- ## 数据库索引

  > - ### 聚集索引与非聚集索引（https://www.cnblogs.com/ghhjanes/p/11208823.html）这个博客写得好
  >
  >   > - 聚集索引表记录的排列顺序和索引的排列顺序一致，所以查询效率快，只要找到第一个索引值记录，其余就连续性的记录在物理也一样连续存放。聚集索引对应的缺点就是修改慢，因为为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序。（所以数据频繁插入删除的情况不建议用聚集索引）![截屏2021-07-25 下午8.25.28](/Users/jackiez/学海/Java开发笔记/picture/截屏2021-07-25 下午8.25.28-7216159.png)
  >   >
  >   > - 非聚集索引指定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致，两种索引都采用B+树结构，非聚集索引的叶子层并不和实际数据页相重叠，而采用叶子层包含一个指向表中的记录在数据页中的指针方式。非聚集索引层次多，不会造成数据重排。
  >   >
  >   >   ![image-20210725193121745](/Users/jackiez/学海/Java开发笔记/picture/image-20210725193121745-7212684.png)
  >
  > - 覆盖索引和回表、联合索引：https://www.jianshu.com/p/8991cbca3854

- ## 数据库优化

  > - 索引优化（检索性能和修改性能是矛盾的）
  >
  >   > - 不要在重复数据多的列建索引
  >   >
  >   > - 尽量利用覆盖索引
  >   >
  >   > - 一个表的索引尽量不要超过5个
  >   >
  >   > - 在经常需要排序的列上创建索引
  >   >
  >   > - 表要是不大，其实用不着用索引
  >   >
  >   > - 如果使用select xxx where abc = ？比较频繁，也就是说查询某列比较多，则可以为该列创建索引。
  >   >
  >   >   
  >
  > - 查询优化（尤其是查询优化）
  >
  > - 分库分表（https://blog.csdn.net/azhuyangjun/article/details/86976514）

- mysql函数（尤其是查询）

- mysql的char和varchar的区别

  > - varchar与char
  >
  >   ![image-20210325101034755](file:///Users/jackiez/%E5%AD%A6%E6%B5%B7/Java%E5%BC%80%E5%8F%91%E7%AC%94%E8%AE%B0/picture/vchar%20vs%20char.png?lastModify=1627211741)
  >
  > - 字段约束
  >
  >   > not null（非空约束）：被约束的字段不能为null值
  >   >
  >   > unique（唯一性约束）: 被约束的字段不能有重复的值，但是可以有多个null值
  >   >
  >   > primary key（主键约束）：被约束的字段不能重复，而且不能出现null
  >   >
  >   > foreign key（外键约束）：被约束的字段的值需来自于关联的一方表中主键字段的值，可存null值 

- ## Redis

  > - ### Redis的淘汰机制以及过期策略
  >
  >   > - 过期策略：
  >   >
  >   >   ​	Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。 对于散列表这种容器，只能为整个键设置过期时间(整个散列表)，而不能为键里面的单个元素设置过期时间。
  >   >
  >   >   > - 定时策略：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。
  >   >   > - 惰性策略：key过期的时候不删除，每次从redis数据库获取key的时候去检查是否过期，若过期，则删除，返回null。
  >   >   > - 定期策略：每隔一段时间对设置了缓存时间的key进行检测，如果key已经失效，则从内存中删除，如果未失效，则不作任何处理。
  >   >
  >   > - 淘汰机制：
  >   >
  >   >   ​	可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。
  >   >
  >   >   > - volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
  >   >   > - volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰
  >   >   > - volatile-random 从已设置过期时间的数据集中任意选择数据淘汰
  >   >   > - allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰
  >   >   > - allkeys-random 从所有数据集中任意选择数据进行淘汰
  >   >   > - noeviction 禁止驱逐数据
  >
  > - 穿透、击穿、雪崩
  >
  >   > - Redis如何防止雪崩？
  >   >
  >   >   1. 什么是Redis缓存雪崩：
  >   >
  >   >   ​    Redis不可能把所有的数据都缓存起来(内存昂贵且有限)，所以Redis需要对数据设置过期时间，并采用的是惰性删除+定期删除两种策略对过期键删除。如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。这就是Redis缓存雪崩。缓存雪崩会造成数据库直接崩溃，从而导致整个系统瘫痪。
  >   >
  >   >   2. 如何防止Redis缓存雪崩：
  >   >
  >   >   （1）在缓存的时候给时间加上一个随机值，设置不同的缓存过期时间，减少缓存在同一时间过期的概率。
  >   >
  >   >   （2）或者设置缓存永不过期，数据有更新再主动更新。
  >   >
  >   > - Redis如何防止穿透？
  >   >
  >   >   1. 什么是Redis缓存穿透：
  >   >
  >   >   在数据库中，正常的数据库表ID都是从1开始的（正数），但是可能有黑客想要进行破坏，所以每次发送的请求ID值都是负数。而Redis缓存中并没有ID为负数的键，导致Redis缓存失效，所有请求都去请求数据库了，而数据库也没有这个负的ID值，所以每次都是返回空，导致Redis也不会记录。所以这个不存在的数据每次请求都能够越过Redis直接请求数据库，使得Redis缓存失去了意义。这就是缓存穿透，如果大量的请求数据在缓存中不命中，导致请求直接走数据库，就有可能导致数据库崩溃，导致整个系统瘫痪。
  >   >
  >   >   2. 如何防止Redis缓存穿透：
  >   >
  >   >   (1)由于请求的参数是不合法的（每次都请求不存在的参数），所以我们可以使用布隆过滤器（BloomFilter）或者压缩filter提前拦截，不合法的请求就不能请求到数据库层。
  >   >
  >   >   (2)如果通过某一个key去查询数据，而对应的数据库中不存在该数据，则可以将此key对应的value设置为一个默认的值，比如说null，并设置一个缓存的失效时间，这样，在缓存失效之前，所有的这个key的请求都会被Redis缓存挡住了。后面如果此key对应的数据在数据库中存在时，缓存失效之后，再通过此key再去访问数据，就能拿到新的value了。
  >   >
  >   > - Redis如何防止击穿？
  >   >
  >   >   1. 什么是Redis缓存击穿（热点key）：
  >   >
  >   >   缓存中的某一个key（比如说一个促销商品），在某个时间点过期的时候，刚好在这个时间点有大量的这个key的请求发送过来，这时就会有大量的请求直接访问数据库，可能会把数据库搞崩溃，从而导致系统瘫痪。
  >   >
  >   >   2. 如何防止Redis缓存击穿：
  >   >
  >   >   （1）在对数据库查询的时候使用互斥锁，如果缓存过期了，在大量的请求中就只能有一个线程能够拿到查询数据库的锁，而其他的请求只能进入等待状态，等该线程进行完查询操作后，把拿到的数据写入Redis缓存中，重新设置缓存过期时间，这样其他的请求又会请求到Redis缓存，避免了数据库的崩溃。
  >   >
  >   >   （2）根据情况可以设置热点key永不过期,配合定时任务更新cache,或者数据有更新再主动更新。
  >
  > - redis基本数据类型
  >
  >   > - String
  >   >
  >   >   底层数据结构：类似于ArrayList里面存字符，是动态字符串（支持扩容）
  >   >
  >   >   ![image-20210713165433052](/Users/jackiez/学海/Java开发笔记/picture/image-20210713165433052-6166478.png)
  >   >
  >   > - HashMap
  >   >
  >   >   应用：简单版购物车或订单
  >   >
  >   >   特别适合存储对象，类似Java里面的Map<String,Object>  ->  Map<String,Map(String,String)>
  >   >
  >   >   ​																											user1           id        1
  >   >
  >   > - List
  >   >
  >   >   应用：微信文章订阅公众号
  >   >
  >   >   底层：quickList（数组+双向链表的思想）
  >   >
  >   >   ​	一块连续的内存存储，这个结构是ziplist，而quickList如下图，减少指针对空间的浪费
  >   >
  >   >   <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716102516868.png" alt="image-20210716102516868" style="zoom:50%;" />
  >   >
  >   > - Set
  >   >
  >   >   底层：hashmap
  >   >
  >   >   <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210713170705479.png" alt="image-20210713170705479" style="zoom:50%;" />
  >   >
  >   > - zset
  >   >
  >   >   底层：hashmap+跳跃表
  >   >   
  >   >   <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716104801551.png" alt="image-20210716104801551" style="zoom:50%;" />
  >   >   
  >   >   ![image-20210713171158045](/Users/jackiez/学海/Java开发笔记/picture/image-20210713171158045-6167520.png)
  >
  > - 布隆过滤器
  >
  >   > ​	直观的说，bloom算法类似一个hash set，用来判断某个元素（key）是否在某个集合中。和一般的hash set不同的是，这个算法无需存储key的值，对于每个key，只需要k个比特位，每个存储一个标志，用来判断key是否在集合中。
  >   >
  >   > 算法：
  >   >
  >   > 1. 首先需要k个hash函数，每个函数可以把key散列成为1个整数
  >   > 2. 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0
  >   > 3. 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1
  >   > 4.  判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。
  >   >
  >   > **优点**：不需要存储key，节省空间
  >   >
  >   > **缺点**：
  >   >
  >   > 1. 算法判断key在集合中时，有一定的概率key其实不在集合中
  >   > 2. 无法删除
  >
  > - 基本数据结构与应用
  >
  >   <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210715214729907.png" alt="image-20210715214729907" style="zoom:50%;" />
  >
  > - redis事务
  >
  >   > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716115731560.png" alt="image-20210716115731560" style="zoom:33%;" />
  >   >
  >   > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716115749330.png" alt="image-20210716115749330" style="zoom:33%;" />
  >   >
  >   > redis事务三大特性：
  >   >
  >   > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716121058279.png" alt="image-20210716121058279" style="zoom:50%;" />
  >   >
  >   > - redis是单线程，顺序执行，那为什么还需要事务呢？
  >   >
  >   >   > 因为客户端是多线程，即大量的客户端可能并发访问redis，虽然redis是单线程顺序执行，但是可能redis执行的顺序并不是我们想要的顺序（），所以必须保证操作的原子性（用事务和watch指令（CAS乐观锁）来解决。）。比如银行卡扣款问题，获取余额，判断，扣款，写回就必须构成事务，否则就可能出错
  >
  > - ## Redis 如何保证缓存与数据库双写时的数据一致性
  >
  >   https://blog.csdn.net/jsloveyou/article/details/107479845
  >
  >   > - 先修改数据库，再删redis缓存。（读操作比写操作快，产生的脏数据少）
  >   > - 强一致性：使用分布式锁来串行化，但是这样吞吐量极低而且很复杂，不推荐。
  >
  > - redis集群部署情况？
  >
  > - 简述kafka，如何实现生产者和消费者
  >
  > - redis分布式锁
  >
  > - redis会出现因为多线程而造成数据读写错误吗
  >
  >   不会
  >
  > - redis之前是使用了单线程，但是redis6.0采用了多线程，你觉得为什么要这么改
  >
  >   > - 为了应对越来越复杂的qps要求，redis做出了让步，但是redis6.0默认是禁止多线程的，可以在配置中打开，选择权交给了用户
  >   >
  >   > - 单线程
  >   >
  >   >   <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716100734501.png" alt="image-20210716100734501" style="zoom:50%;" />
  >   >
  >   > - <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716094926397.png" alt="image-20210716094926397" style="zoom:50%;" />
  >
  > - redis哨兵模式
  >
  >   > - 主要作用：能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库
  >
  > - redis主从复制
  >
  >   > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716141044452.png" alt="image-20210716141044452" style="zoom:50%;" />
  >
  > - redis集群
  >
  >   - **Redis** **集群提供了以下好处**
  >
  >     实现扩容
  >
  >     分摊压力
  >
  >     无中心配置相对简单
  >
  >   - **Redis** **集群的不足**
  >
  >     多键操作是不被支持的 
  >
  >     多键的Redis事务是不被支持的。lua脚本不被支持
  >
  >     由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。
  >
  > - redis字典结构的hash问题
  >
  > - ## 跳表
  >
  >   > 跳表插入、删除、查找元素的时间复杂度跟红黑树都是一样量级的，时间复杂度都是O(logn)，而且跳表有一个特性是红黑树无法匹敌的: 按照区间来查找数据这个操作，红黑树的效率没有跳表高。