- ## MYSQL的A C I D怎样实现的？

  > - 原子性：事务被视为不可分割的最小单元，事务的所有操作要么全部提交成功，要么全部失败回滚。
  >
  >   > 如何保证？利用回滚日志Undo
  >
  > - 一致性：数据库在事务执行前后都保持一致性状态。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
  >
  >   > 如何保证？通过原子性，隔离性，持久性来保证一致性
  >
  > - 隔离性：一个事务所做的修改在最终提交以前，对其它事务是不可见的。
  >
  >   > 如何保证？锁和MVCC机制
  >
  > - 持久性：一旦事务提交，则其所做的修改将会永远保存到数据库中。即使系统发生崩溃，事务执行的结果也不能丢失。
  >
  >   > 如何保证？利用redo日志

- ## MYSQL的事务隔离机制/级别（4种隔离级别）

  > - 未提交读：事务中的修改，即使没有提交，对其它事务也是可见的。
  > - 提交读：一个事务只能读取已经提交的事务所做的修改。换句话说，一个事务所做的修改在提交之前对其它事务是不可见的。
  > - 可重复读：保证在同一个事务中多次读取同样数据的结果是一样的。
  > - 可串行化：强制事务串行执行。（需要加锁实现，而其它隔离级别通常不需要）

- ## MVCC

  > - 定义：多版本并发控制(Multi-Version Concurrency Control, MVCC)是 MySQL 的 InnoDB 存储引擎实现隔离级别的一种具体方式，用于实现提交读和可重复读这两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用 MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用 MVCC 无法实现。
  >
  > - 原理：利用版本号来实现。
  >
  >   ```java
  >   /*
  >     系统版本号:是一个递增的数字，每开始一个新的事务，系统版本号就会自动递增。
  >     事务版本号:事务开始时的系统版本号。
  >   */
  >   MVCC 在每行记录后面都保存着两个隐藏的列，用来存储两个版本号:
  >   	1.创建版本号:指示创建或更新一个数据行的快照时的系统版本号;当开始一个事务时，该事务的版本号肯定大于当前所有数据行快照的创建版本号,理解这点很关键。
  >   	2.删除版本号:指删除或更新一个数据行的快照时的系统版本号。如果该快照的删除版本号大于当前事务版本号表示该快照有效，否则表示该快照已经被删除了。
  >     MVCC 使用到的快照存储在 Undo日志中，该日志通过回滚指针把一个数据行(Record)的所有快照连接起来。
  >   ```


- ## 数据库三大范式

  > - 第一范式:  确保每列保持原子性
  >
  >   ​	比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。这样设计才算满足了数据库的第一范式
  >
  > - 第二范式:  确保表中的每列都和主键相关(拒绝联合主键)
  >
  >   ​	比如要设计一个订单信息表，因为订单中可能会有多种商品，所以要将订单编号和商品编号作为数据库表的联合主键，这样就产生一个问题：这个表中是以订单编号和商品编号作为联合主键。这样在该表中商品名称、单位、商品价格等信息不与该表的主键相关，而仅仅是与商品编号相关。所以在这里违反了第二范式的设计原则。而如果把这个订单信息表进行拆分，把商品信息分离到另一个表中，把订单项目表也分离到另一个表中，就非常完美了
  >
  > - 第三范式：确保每列都和主键列直接相关,而不是间接相关（数据不能存在传递关系）
  >
  >   ​	比如在设计一个订单数据表的时候，可以将客户编号作为一个外键和订单表建立相应的关系。而不可以在订单表中添加关于客户其它信息（比如姓名、所属公司等）的字段。如下面这两个表所示的设计就是一个满足第三范式的数据库表。

- ## 数据库mysql底层：B+ Tree

  > - 一棵m阶的B-Tree有如下特性:
  >
  >   > 1. 每个节点最多有m个孩子。 
  >   > 2. 除了根节点和叶子节点外，其它每个节点至少有Ceil(m/2)个孩子。 
  >   > 3. 若根节点不是叶子节点，则至少有2个孩子 
  >   > 4. 所有叶子节点都在同一层，且不包含其它关键字信息 
  >   > 5. 每个非终端节点包含n个关键字信息（P0,P1,…Pn, k1,…kn） 
  >   > 6. 关键字的个数n满足：ceil(m/2)-1 <= n <= m-1 
  >   > 7. ki(i=1,…n)为关键字，且关键字升序排序。 
  >   > 8. Pi(i=1,…n)为指向子树根节点的指针。P(i-1)指向的子树的所有节点关键字均小于ki，但都大于k(i-1)
  >
  > - B+ Tree 和B Tree的区别：
  >
  >   > 1. 非叶子结点的子树指针与关键字个数相同；
  >   > 2. 非叶子结点的子树指针P[i]，指向关键字值属于[K[i], K[i+1])的子树（B-树是开区间）
  >   > 3. 为所有叶子结点增加一个链指针。图中Q是通过指针连在一起的。
  >   > 4. 所有关键字都在叶子结点出现。（5 8 9 10 15 18 20 26 ...等等）叶子结点相当于是存储（关键字）数据的数据层；
  >   > 5. B+树只有达到叶子结点才命中（B-树可以在非叶子结点命中）
  >   > 6. 所有的非终端结点可以看成是索引部分，结点中的关键字是有其孩子指向的子树中最大（或最小）关键字。`比如第二层5 它的子树为5 8 9` (而B 树的非终节点也包含需要查找的有效信息)
  >
  > - 数据底层为什么要选择B+ Tree（优势）

- ## 跳表

  > 跳表插入、删除、查找元素的时间复杂度跟红黑树都是一样量级的，时间复杂度都是O(logn)，而且跳表有一个特性是红黑树无法匹敌的: 按照区间来查找数据这个操作，红黑树的效率没有跳表高。

- 数据库索引了解吗？

- mysql函数（尤其是查询）

- mysql的char和varchar的区别

- 回表问题

- ## Redis

  > - ### Redis的淘汰机制以及过期策略
  >
  >   > - 过期策略：
  >   >
  >   >   ​	Redis 可以为每个键设置过期时间，当键过期时，会自动删除该键。 对于散列表这种容器，只能为整个键设置过期时间(整个散列表)，而不能为键里面的单个元素设置过期时间。
  >   >
  >   >   > - 定时策略：在设置key的过期时间的同时，为该key创建一个定时器，让定时器在key的过期时间来临时，对key进行删除。
  >   >   > - 惰性策略：key过期的时候不删除，每次从数据库获取key的时候去检查是否过期，若过期，则删除，返回null。
  >   >   > - 定期策略：每隔一段时间对设置了缓存时间的key进行检测，如果key已经失效，则从内存中删除，如果未失效，则不作任何处理。
  >   >
  >   > - 淘汰机制：
  >   >
  >   >   ​	可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。
  >   >
  >   >   > - volatile-lru 从已设置过期时间的数据集中挑选最近最少使用的数据淘汰
  >   >   > - volatile-ttl 从已设置过期时间的数据集中挑选将要过期的数据淘汰
  >   >   > - volatile-random 从已设置过期时间的数据集中任意选择数据淘汰
  >   >   > - allkeys-lru 从所有数据集中挑选最近最少使用的数据淘汰
  >   >   > - allkeys-random 从所有数据集中任意选择数据进行淘汰
  >   >   > - noeviction 禁止驱逐数据
  >
  > - 穿透、击穿、雪崩
  >
  >   > - Redis如何防止雪崩？
  >   >
  >   >   1. 什么是Redis缓存雪崩：
  >   >
  >   >   ​    Redis不可能把所有的数据都缓存起来(内存昂贵且有限)，所以Redis需要对数据设置过期时间，并采用的是惰性删除+定期删除两种策略对过期键删除。如果缓存数据设置的过期时间是相同的，并且Redis恰好将这部分数据全部删光了。这就会导致在这段时间内，这些缓存同时失效，全部请求到数据库中。这就是Redis缓存雪崩。缓存雪崩会造成数据库直接崩溃，从而导致整个系统瘫痪。
  >   >
  >   >   2. 如何防止Redis缓存雪崩：
  >   >
  >   >   （1）在缓存的时候给时间加上一个随机值，设置不同的缓存过期时间，减少缓存在同一时间过期的概率。
  >   >
  >   >   （2）或者设置缓存永不过期，数据有更新再主动更新。
  >   >
  >   > - Redis如何防止穿透？
  >   >
  >   >   1. 什么是Redis缓存穿透：
  >   >
  >   >   在数据库中，正常的数据库表ID都是从1开始的（正数），但是可能有黑客想要进行破坏，所以每次发送的请求ID值都是负数。而Redis缓存中并没有ID为负数的键，导致Redis缓存失效，所有请求都去请求数据库了，而数据库也没有这个负的ID值，所以每次都是返回空，导致Redis也不会记录。所以这个不存在的数据每次请求都能够越过Redis直接请求数据库，使得Redis缓存失去了意义。这就是缓存穿透，如果大量的请求数据在缓存中不命中，导致请求直接走数据库，就有可能导致数据库崩溃，导致整个系统瘫痪。
  >   >
  >   >   2. 如何防止Redis缓存穿透：
  >   >
  >   >   (1)由于请求的参数是不合法的（每次都请求不存在的参数），所以我们可以使用布隆过滤器（BloomFilter）或者压缩filter提前拦截，不合法的请求就不能请求到数据库层。
  >   >
  >   >   (2)如果通过某一个key去查询数据，而对应的数据库中不存在该数据，则可以将此key对应的value设置为一个默认的值，比如说null，并设置一个缓存的失效时间，这样，在缓存失效之前，所有的这个key的请求都会被Redis缓存挡住了。后面如果此key对应的数据在数据库中存在时，缓存失效之后，再通过此key再去访问数据，就能拿到新的value了。
  >   >
  >   > - Redis如何防止击穿？
  >   >
  >   >   1. 什么是Redis缓存击穿（热点key）：
  >   >
  >   >   缓存中的某一个key（比如说一个促销商品），在某个时间点过期的时候，刚好在这个时间点有大量的这个key的请求发送过来，这时就会有大量的请求直接访问数据库，可能会把数据库搞崩溃，从而导致系统瘫痪。
  >   >
  >   >   2. 如何防止Redis缓存击穿：
  >   >
  >   >   （1）在对数据库查询的时候使用互斥锁，如果缓存过期了，在大量的请求中就只能有一个线程能够拿到查询数据库的锁，而其他的请求只能进入等待状态，等该线程进行完查询操作后，把拿到的数据写入Redis缓存中，重新设置缓存过期时间，这样其他的请求又会请求到Redis缓存，避免了数据库的崩溃。
  >   >
  >   >   （2）根据情况可以设置热点key永不过期,配合定时任务更新cache,或者数据有更新再主动更新。
  >
  > - redis基本数据类型
  >
  >   > - String
  >   >
  >   >   底层数据结构：类似于ArrayList里面存字符，是动态字符串（支持扩容）
  >   >
  >   >   ![image-20210713165433052](/Users/jackiez/学海/Java开发笔记/picture/image-20210713165433052-6166478.png)
  >   >
  >   > - HashMap
  >   >
  >   >   应用：简单版购物车或订单
  >   >
  >   >   特别适合存储对象，类似Java里面的Map<String,Object>  ->  Map<String,Map(String,String)>
  >   >
  >   >   ​																											user1           id        1
  >   >
  >   > - List
  >   >
  >   >   应用：微信文章订阅公众号
  >   >
  >   >   底层：quickList（数组+双向链表的思想）
  >   >
  >   >   ​	一块连续的内存存储，这个结构是ziplist，而quickList如下图，减少指针对空间的浪费
  >   >
  >   >   <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716102516868.png" alt="image-20210716102516868" style="zoom:50%;" />
  >   >
  >   > - Set
  >   >
  >   >   底层：hashmap
  >   >
  >   >   <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210713170705479.png" alt="image-20210713170705479" style="zoom:50%;" />
  >   >
  >   > - zset
  >   >
  >   >   底层：hashmap+跳跃表
  >   >   
  >   >   <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716104801551.png" alt="image-20210716104801551" style="zoom:50%;" />
  >   >   
  >   >   ![image-20210713171158045](/Users/jackiez/学海/Java开发笔记/picture/image-20210713171158045-6167520.png)
  >
  > - 布隆过滤器
  >
  >   > ​	直观的说，bloom算法类似一个hash set，用来判断某个元素（key）是否在某个集合中。和一般的hash set不同的是，这个算法无需存储key的值，对于每个key，只需要k个比特位，每个存储一个标志，用来判断key是否在集合中。
  >   >
  >   > 算法：
  >   >
  >   > 1. 首先需要k个hash函数，每个函数可以把key散列成为1个整数
  >   > 2. 初始化时，需要一个长度为n比特的数组，每个比特位初始化为0
  >   > 3. 某个key加入集合时，用k个hash函数计算出k个散列值，并把数组中对应的比特位置为1
  >   > 4.  判断某个key是否在集合时，用k个hash函数计算出k个散列值，并查询数组中对应的比特位，如果所有的比特位都是1，认为在集合中。
  >   >
  >   > **优点**：不需要存储key，节省空间
  >   >
  >   > **缺点**：
  >   >
  >   > 1. 算法判断key在集合中时，有一定的概率key其实不在集合中
  >   > 2. 无法删除
  >
  > - 基本数据结构与应用
  >
  >   <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210715214729907.png" alt="image-20210715214729907" style="zoom:50%;" />
  >
  > - redis事务
  >
  >   > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716115731560.png" alt="image-20210716115731560" style="zoom:50%;" />
  >   >
  >   > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716115749330.png" alt="image-20210716115749330" style="zoom:50%;" />
  >   >
  >   > redis事务三大特性：
  >   >
  >   > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716121058279.png" alt="image-20210716121058279" style="zoom:50%;" />
  >   >
  >   > - redis是单线程，顺序执行，那为什么还需要事务呢？
  >   >
  >   >   > 因为客户端是多线程，即大量的客户端可能并发访问redis，虽然redis是单线程顺序执行，但是可能redis执行的顺序并不是我们想要的顺序（），所以必须保证操作的原子性（用事务和watch指令（CAS乐观锁）来解决。）。比如银行卡扣款问题，获取余额，判断，扣款，写回就必须构成事务，否则就可能出错
  >
  > - redis集群部署情况？
  >
  > - 简述kafka，如何实现生产者和消费者
  >
  > - redis会出现因为多线程而造成数据读写错误吗
  >
  >   不会
  >
  > - redis之前是使用了单线程，但是redis6.0采用了多线程，你觉得为什么要这么改
  >
  >   > - 为了应对越来越复杂的qps要求，redis做出了让步，但是redis6.0默认是禁止多线程的，可以在配置中打开，选择权交给了用户
  >   >
  >   > - 单线程
  >   >
  >   >   <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716100734501.png" alt="image-20210716100734501" style="zoom:50%;" />
  >   >
  >   > - <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716094926397.png" alt="image-20210716094926397" style="zoom:50%;" />
  >
  > - redis哨兵模式
  >
  >   > - 主要作用：能够后台监控主机是否故障，如果故障了根据投票数自动将从库转换为主库
  >
  > - redis主从复制
  >
  >   > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210716141044452.png" alt="image-20210716141044452" style="zoom:50%;" />
  >   
  > - redis集群
  >
  >   - **Redis** **集群提供了以下好处**
  >
  >     实现扩容
  >
  >     分摊压力
  >
  >     无中心配置相对简单
  >
  >   - **Redis** **集群的不足**
  >
  >     多键操作是不被支持的 
  >
  >     多键的Redis事务是不被支持的。lua脚本不被支持
  >
  >     由于集群方案出现较晚，很多公司已经采用了其他的集群方案，而代理或者客户端分片的方案想要迁移至redis cluster，需要整体迁移而不是逐步过渡，复杂度较大。