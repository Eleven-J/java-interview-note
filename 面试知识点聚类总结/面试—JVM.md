- ## JVM运行期内存空间（内存模型），每块的作用

  > - 线程私有，不用进行垃圾回收，线程结束即消失。
  >
  >   > - 程序计数器：记录的是正在执行的字节码的地址
  >   > - 虚拟机栈：每个方法会创建一个栈帧来存放相应的局部变量，常量池引用等信息。从方法调用直至 执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程
  >   > - 本地方法栈：与虚拟机栈类似，只不过本地方法栈是为本地方法服务。
  >
  > - 需要进行垃圾回收
  >
  >   > - 方法区：用于存储已经被虚拟机加载的类信息、常量、静态常量、 即时编译器编译后的代码等数据。方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。在 JDK 1.8 之后，移除永久代，原来永久代的数据被分到了堆和元 空间中。**元空间存储类的元信息，静态变量和常量池等放入堆中**。
  >   > - 堆：所有对象都在这里分配内存，是垃圾收集的主要区域("GC 堆")。

- ## java内存泄漏

  > - 长生命周期的对象持有短生命周期的引用:  尽量降低变量的作用域
  > - 静态集合类引起内存泄漏
  > - **各种连接**不执行close()方法导致的内存泄漏
  > - 内部类和外部模块的引用
  > - 不正确使用单例模式：单例对象在初始化后将在JVM的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被JVM正常回收，导致内存泄漏

- ## 字符串常量池：**（有疑问？）**

  > - 存放位置：1.7以前在方法区，1.8在堆中。
  > - 对于直接做+运算的两个字符串（字面量）常量，并不会放入字符串常量池中，而是直接把运算后的结果放入字符串常量池中(String s = "abc"+ "def", 会直接生成“abcdef"字符串常量  而不把 "abc" "def"放进常量池) 
  > - 对于先声明的字符串字面量常量，会放入字符串常量池，但是若使用字面量的引用进行运算就不会把运算后的结果放入字符串常量池中了
  >   (String s = new String("abc") + new String("def"),在构造过程中不会生成“abcdef"字符串常量) 
  > - **常量池中同时存在字符串常量和字符串引用。**直接赋值和用字符串调用String构造函数都可能导致常量池中生成字符串常量;而intern()方法会尝试将堆中对象的引用放入常量池

- 虚拟机的类加载机制，具体步骤及对应完成的事情

  > - 加载阶段：通过类的全限定名称获取定义该类的二进制字节流，将其表示静态存储结构转换为方法区的运行时存储结构，在堆内存中生成一个Class对象，作为方法区中该类各种数据的访问入口。
  > - 验证阶段：确保Class文件的字节流中包含的信息符合java虚拟机要求。
  > - 准备阶段：为 类变量分配内存并设置初始值。
  > - 解析阶段：将常量池的符号引用替换为直接引用
  > - 初始化阶段：该阶段才真正开始执行类中定义的java程序代码，执行类的构造器<clinit>()方法，根据程序制定的主观计划去初始化类变量和其他资源 .

- JVM的双亲委派模型

  > - 双亲委派机制就是如果一个类加载器收到了类加载请求，它首先不会自己尝试去加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有父类加载器反馈到无法完成这个加载请求（它的搜索范围没有找到这个类），子加载器才会尝试自己去加载。
  > - 启动类加载器（jvm的一部分）
  > - 扩展类加载器 （java.lang.ClassLoader）
  > - 应用程序类加载器（java.lang.ClassLoader）
  > - 自定义加载器

- JVM 垃圾回收机制（GC）

  > - 如何判断对象是否可被回收
  >
  >   > 可达性分析，GC Roots：
  >   >
  >   > - 虚拟机栈中局部变量表中引用的对象 
  >   > - 本地方法栈中 JNI 中引用的对象 
  >   > - 方法区中类静态属性引用的对象 
  >   > - 方法区中的常量引用的对象
  >
  > - 引用类型
  >
  >   > - 强引用
  >   > - 软引用
  >   > - 弱引用
  >   > - 虚引用
  >
  > - 垃圾回收大致流程
  >
  >   > 1. 可达性分析判断不可达的对象并进行标记
  >   > 2. 
  >
  > - JVM垃圾收集每种[算法](https://www.nowcoder.com/jump/super-jump/word?word=算法)，实现方式，各自特点
  >
  >   > - 标记-清除
  >   >
  >   >   > - 实现方式：简单的标记，然后清除掉
  >   >   >
  >   >   > - 缺点：
  >   >   >
  >   >   >   > - 标记和清除过程效率都不高;
  >   >   >   > - 会产生大量不连续的内存碎片，导致无法给大对象分配内存，从而又触发新的一次垃圾收集。
  >   >
  >   > - 复制
  >   >
  >   >   > - 实现方式：将内存一分为二，只用一半，垃圾收集时将还存活的对象复制到另外一半空内存空间上，然后对用了的这一半一次全部清除，这样就不存在产生大量内存碎片的问题了。
  >   >   > - 缺点：虽然不存在内存碎片的问题，但是代价却是巨大的，因为实际可使用内存减半了。
  >   >
  >   > - 标记-整理
  >   >
  >   >   > - 实现方式：标记阶段与标记-清除算法一样，整理阶段是不直接清除可回收对象，而是先将存活对象都向一端移动，然后再清理端边界以外的内存。
  >   >   > - 缺点：需要移动大量对象，处理效率比较低。
  >   >
  >   > - 分代收集
  >   >
  >   >   > - 实现方式：将堆区划分为老年代和新生代，老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。对于新生代都采取**复制算法**因为新生代中每次垃圾回收都要回收大部分对象，也就是说需要复制的操作次数较少，但是实际中并不是按照1：1的比例来划分新生代的空间的，一般来说是将新生代划分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden空间和其中的一块Survivor空间，当进行回收时，将Eden和Survivor中还存活的对象复制到另一块Survivor空间中，然后清理掉Eden和刚才使用过的Survivor空间；而由于老年代的特点是每次回收都只回收少量对象，一般使用的是**标记-整理算法（压缩法）**。
  >
  > - 垃圾回收器（技术面试必备基础知识p330页）
  >
  >     > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210712160844567.png" alt="image-20210712160844567" style="zoom:50%;" />
  >     >
  >     > ![image-20210712164916098](/Users/jackiez/学海/Java开发笔记/picture/image-20210712164916098-6079758.png)
  >     >
  >     > ![image-20210712173620887](/Users/jackiez/学海/Java开发笔记/picture/image-20210712173620887-6082582.png)
  >     >
  >     > ![image-20210712163424913](/Users/jackiez/学海/Java开发笔记/picture/image-20210712163424913-6078867.png)
  >     >
  >     > ![image-20210712163747424](/Users/jackiez/学海/Java开发笔记/picture/image-20210712163747424.png)
  >     >
  >     > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210712164339978.png" alt="image-20210712164339978" style="zoom:50%;" />
  >     >
  >     > ![image-20210712164607741](/Users/jackiez/学海/Java开发笔记/picture/image-20210712164607741-6079569.png)
  >     >
  >     > ![image-20210712165356205](/Users/jackiez/学海/Java开发笔记/picture/image-20210712165356205-6080039.png)
  >     >
  >     > ![image-20210712170021769](/Users/jackiez/学海/Java开发笔记/picture/image-20210712170021769-6080423.png)
  >     >
  >     > ![image-20210712170231882](/Users/jackiez/学海/Java开发笔记/picture/image-20210712170231882.png)
  >     >
  >     > ![image-20210712170514689](/Users/jackiez/学海/Java开发笔记/picture/image-20210712170514689-6080716.png)
  >     >
  >     > ![image-20210712170822276](/Users/jackiez/学海/Java开发笔记/picture/image-20210712170822276-6080904.png)
  >     >
  >     > ![image-20210712171012140](/Users/jackiez/学海/Java开发笔记/picture/image-20210712171012140-6081014.png)
  >     >
  >     > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210712171116909.png" alt="image-20210712171116909" style="zoom:50%;" />![image-20210712171415218](/Users/jackiez/学海/Java开发笔记/picture/image-20210712171415218-6081257.png)
  >     >
  >     > ![image-20210712171652754](/Users/jackiez/学海/Java开发笔记/picture/image-20210712171652754.png)
  >     >
  >     > ![image-20210712172026237](/Users/jackiez/学海/Java开发笔记/picture/image-20210712172026237-6081628.png)
  >     >
  >     > ![image-20210712172131647](/Users/jackiez/学海/Java开发笔记/picture/image-20210712172131647-6081693.png)
  >
  > - 内存分配策略
  >
  >   > 1. 对象优先在 Eden 分配
  >   >     	大多数情况下，对象在新生代 Eden 上分配，当 Eden 空间不够时，发起 Minor GC。
  >   >
  >   > 2.  大对象直接进入老年代 
  >   >
  >   >    ​	大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。
  >   >
  >   > 3.  长期存活的对象进入老年代 
  >   >
  >   >    ​	为对象定义年龄计数器，对象在 Eden 出生并经过 Minor GC 依然存活，将移动到 Survivor 中，年龄就增加 1 岁， 增加到一定年龄则移动到老年代中。 XX:MaxTenuringThreshold 用来定义年龄的阈值。
  >   >
  >   > 4. 动态对象年龄判定 
  >   >
  >   >    ​	虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄 所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。
  >   >
  >   > 5. 空间分配担保
  >   >
  >   >    在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代 最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC;如果小 于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。
  >
  > - Full GC 的触发条件
  >    对于 Minor GC，其触发条件非常简单，当 Eden 空间满时，就将触发一次 Minor GC。而 Full GC 则相对复杂，有以下条件:
  >
  >   1. 调用 System.gc()
  >       只是建议虚拟机执行 Full GC，但是虚拟机不一定真正去执行。不建议使用这种方式，而是让虚拟机管理内存。
  >   2. 年代空间不足 老年代空间不足的常见场景为前文所讲的大对象直接进入老年代、长期存活的对象进入老年代等。为了避免以上原因引起的 Full GC，应当尽量不要创建过大的对象以及数组。除此之外，可以通过 -Xmn 虚拟机参数 调大新生代的大小，让对象尽量在新生代被回收掉，不进入老年代。还可以通过 -XX:MaxTenuringThreshold 调大对 象进入老年代的年龄，让对象在新生代多存活一段时间。
  >
  >   3. 空间分配担保失败
  >       使用复制算法的 Minor GC 需要老年代的内存空间作担保，如果担保失败会执行一次 Full GC。
  >
  >   4. Concurrent Mode Failure
  >
  >      执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足(可能是 GC 过程中浮动垃圾过多导致暂时 性的空间不足)，便会报 Concurrent Mode Failure 错误，并触发 Full GC。