- JDK1.8相比于JDK1.7多了哪些功能，做了哪些优化？

  > - 在**JDK1.8** hotspot移除了**永久代**用**元空间(****Metaspace)**
  > - hashmap，CurrentHashmap
  
- Collection

  <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210616120909902.png" alt="image-20210616120909902" style="zoom:50%;" />
  
  <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210616120942117.png" alt="image-20210616120942117" style="zoom:50%;" />
  
- HashMap

  > - HashMap的工作原理是什么？
  >
  >   > - HashMap 底层是 hash 数组和单向链表实现，数组中的每个元素都是链表，由 Node 内部类（实现 Map.Entry接口）实现，HashMap 通过 put & get 方法存储和获取。
  >   >
  >   > - put过程：
  >   >
  >   >   ①调用 hash(K) 方法计算 K 的 hash 值，然后结合数组长度，计算得数组下标；
  >   >
  >   >   ②调整数组大小（当容器中的元素个数大于 capacity * loadfactor 时，容器会进行扩容resize 为 2n）；
  >   >
  >   >   ③i.如果 K 的 hash 值在 HashMap 中不存在，则执行插入，若存在，则发生碰撞；
  >   >
  >   >      ii.如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 true，则更新键值对；
  >   >
  >   >      iii. 如果 K 的 hash 值在 HashMap 中存在，且它们两者 equals 返回 false，则插入链表的尾部（尾插法）或者红黑树中（树的添加方式）。（JDK 1.7 之前使用头插法、JDK 1.8 使用尾插法：主要是为了防止多线程情况下链表成环，进入死循环状态）（注意：当碰撞导致链表大于 TREEIFY_THRESHOLD = 8 时，就把链表转换成红黑树）
  >   >
  >   > - get过程
  >   >
  >   >   ①调用 hash(K) 方法（计算 K 的 hash 值）从而获取该键值所在链表的数组下标；
  >   >
  >   >   ②顺序遍历链表，equals()方法查找相同 Node 链表中 K 值对应的 V 值。(hashCode 是定位的，存储位置；equals是定性的，比较两者是否相等)
  >
  > - HashMap中的“死锁”是怎么回事？（**多线程，扩容时，头插法和尾插法**）
  >
  >   > 多线程下很有可能会让链表成环，出现死循环。
  >
  > - HashMap中的键值可以为null吗？原理？
  >
  > ​	可以。HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，只能通过强制指定一个桶下标来存放。HashMap 使用第 0 个桶存放键为 null 的键值对。
  >
  > - HashMap扩容机制？
  >
  > ​	初始值默认为16，装载因子为0.75，每次扩容为之前的两倍。初始容量最好是2的n次方，因为扩容的时候是开辟一块新的空间，然后将之前的copy过来，同时需要对应好hash值。由于底层在计算数组下标的时候，采用的是（hash值 & n-1），n位hashmap的容量，而2的幂次方-1的特点是0111...1，进行&运算后能够充分的散列，使得添加的元素均匀分布在HashMap的每个位置上，减少hash碰撞。当然，你要是在构造函数中传入的不是2的n次方，也会自动给你转成2的n次方。
  >
  > ​		扩容前和扩容时put过程的源码对比：
  >
  > <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210714161446989.png" alt="image-20210714161446989" style="zoom:50%;" />
  >
  > - hascode与equals?（为什么重写equals时，要顺便重写hascode）
  >
  >   > ​	hashCode()和equal()一样都是基本类Object里的方法，而和equal()一样，Object里hashCode()里面只是返回当前对象的地址(经过处理的)，如果是这样的话，那么我们相同的一个类，new两个对象，由于他们在内存里的地址不同，则他们的hashCode（）不同，所以这显然不是我们想要的，所以我们必须重写我们类的hashCode()方法，即一个类，在hashCode()里面返回唯一的一个hash值
  >   >
  >   > ​	将对象放入到集合中时，首先判断要放入对象的hashcode值与集合中的任意一个元素的hashcode值是否相等，如果不相等直接将该对象放入集合中。如果hashcode值相等，然后再通过equals方法判断要放入对象与集合中的任意一个对象是否相等，如果equals判断不相等，直接将该元素放入到集合中，否则不放入。
  >
  > - HashMap，LinkedHashMap，TreeMap 有什么区别？
  >
  >   > - LinkedHashMap 保存了记录的插入顺序，在用 Iterator 遍历时，先取到的记录肯定是先插入的；遍历比 HashMap 慢；
  > >
  >   > - TreeMap 实现 SortMap 接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）
  >
  > - jdk8中对HashMap做了哪些改变？
  >
  >   在java 1.8中，如果链表的长度超过了8，那么链表将转换为红黑树。（桶的数量必须大于64，小于64的时候只会扩容）
  >
  >   发生hash碰撞时，java 1.7 会在链表的头部插入，而java 1.8会在链表的尾部插入
  >
  >   在java 1.8中，Entry被Node替代(换了一个马甲）。
  >
  > - 拉链法导致的链表过深问题为什么不用二叉查找树代替，而选择红黑树？为什么不一直使用红黑树？
  >
  >   ​	之所以选择红黑树是为了解决二叉查找树的缺陷，二叉查找树在特殊情况下会变成一条线性结构（这就跟原来使用链表结构一样了，造成很深的问题），遍历查找会非常慢。
  >
  >   ​	而红黑树在插入新数据后可能需要通过左旋，右旋、变色这些操作来保持平衡，引入红黑树就是为了查找数据快，解决链表查询深度的问题，我们知道红黑树属于平衡二叉树，但是为了保持“平衡”是需要付出代价的，但是该代价所损耗的资源要比遍历线性链表要少，所以当长度大于8的时候，会使用红黑树，如果链表长度很短的话，根本不需要引入红黑树，引入反而会慢。
  >
  > - 红黑树？
  >
  >   > - 在JDK1.8中加入了红黑树是为了防止哈希表碰撞攻击，当链表链长度为8时，及时转成红黑树，提高map的效率
  >   >
  >   > - 条件：
  >   >
  >   >   > 1. 节点是红色或黑色。
  >   >   >
  >   >   > 2. 根节点是黑色。
  >   >   >
  >   >   > 3. 每个叶子节点都是黑色的空节点（NIL节点）。
  >   >   >
  >   >   > 4. 每个红色节点的两个子节点都是黑色。(从每个叶子到根的所有路径上不能有两个连续的红色节点)
  >   >   >
  >   >   > 5. 从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。
  >   >
  >   > - 特性：
  >   >
  >   >   自平衡：从根节点到叶子的最长路径不大于最短路径的2倍——这主要是由条件4和条件5决定的
  >   >
  >   > - 应用：
  >   >
  >   >   TreeSet，TreeMap，HashMap，LinkedHashMap
  >
  > - CurrentHashMap
  >
  >   > - 同样是线程安全，它与 HashTable 在线程同步上有什么不同？
  >   >
  >   >   > - HashTable 使用一把锁（锁住整个链表结构）处理并发问题（就是对对象加锁），多个线程竞争一把锁，容易阻塞；
  >   >   >
  >   >   > - 而 ConcurrentHashMap:
  >   >   >
  >   >   >   > - JDK 1.7 中使用分段锁（ReentrantLock + Segment + HashEntry），相当于把一个 HashMap 分成多个段，每段分配一把锁，这样支持多线程访问。锁粒度：基于 Segment，包含多个 HashEntry。
  >   >   >   >- JDK 1.8 中使用 CAS + synchronized + Node + 红黑树。锁粒度：Node（首结点）（实现 Map.Entry）。锁粒度降低了。
  >   >   
  >   > - 扩容机制细节
  >
  > - 分析源码，手写
  
- ArrayList

  > - 创建Arraylist时，无参数构造方法默认容量为10（jdk源码表示：其实创建时容量为0，添加第一个元素时，容量自动默认为10）。Add( )方法触发自动扩容时，默认扩容为原数组列表的1.5倍。
  >
  > - 底层是数组
  >
  > - 如何解决ArrayList线程不安全的问题？
  >
  >   > ![image-20210714210836349](/Users/jackiez/学海/Java开发笔记/picture/image-20210714210836349-6268118.png)
  >
  > - JUC下的CopyOnWriteArrayList( ):写时复制
  >
  >   ​	往一个容器添加元素的时候，不直接往当前容器object[ ]添加，而是先将当前容器object[ ]进行copy，复制出一个新的容器0bject[ ] newElements，然后新的容器object[ ] newElements里添加元素，添加完元素之后，再将原容器的引用指向新的容器setArray （newElements）。这样做的好处是可以对CopyOnwrite容器进行并发的读，而不需要加锁，因为当前容器不会添加任何元素。所以copyOnWrite容器也是一种读写分离的思想，读和写不同的容器。

- 异常

  > - 异常结构：
  >
  >   <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210616114225764.png" alt="image-20210616114225764" style="zoom:50%;" />
  >
  > - 异常分类：
  >
  >   > - 受检异常 :需要用 try...catch... 语句捕获并进行处理，并且可以从异常中恢复，或者需要向上抛出;
  >   > - 非受检异常 :是程序运行时错误，例如除以0 会引发 Arithmetic Exception，此时程序崩溃并且无法恢复。

- > - 

- 抽象类 vs 接口

  > - 接口可以看成是一个完全抽象的类
  > - 一个类可以实现多个接口，但是不能继承多个抽象类
  > - 接口只能是public，抽象类可以有多种访问权限

- 抽象类作用：降低接口实现类与接口之间的实现难度

  > ​	抽象类实现接口，意义如下：一般来说我们使用普通类来实现接口，这个普通类就必须实现接口中所有的方法，这样的结果就是普通类中就需要实现多余的方法，造成代码冗余。但是如果我们使用的是抽象类来实现接口，那么就可以只实现接口中的部分方法，并且当其他类继承这个抽象类时，仍然可以实现接口中有但抽象类并未实现的方法。

- Collection与Map（详细信息见java基础笔记，源码分析见“技术面试必备基础知识”p268）







- final类
- 深拷贝与浅拷贝
- 重载重写以及权限问题