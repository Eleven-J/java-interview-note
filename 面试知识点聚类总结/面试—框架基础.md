- 反射机制（静态类加载 vs 动态类加载？）

- 动态代理机制

  > - 作用：
  >
  >   > - 在目标类源码不改变的情况下增加功能，减少代码的重复
  >   > - 专注业务逻辑代码
  >   > - 解耦合，让业务功能和日志、事务等非业务功能分离
  >
  > - 原理：解决了静态代理不灵活的缺点，不用创建大量的代理类，而是利用反射机制直接生成相应对象
  >
  >   > - 实现分两种：
  >   >
  >   >   > - jdk动态代理：要求目标类必须有接口，需要用到Proxy，Method，InvokationHandler
  >   >   > - cglib动态代理：使用的是继承方式，不要求目标类必须要有接口，效率较jdk更高，多使用于spring等框架中，如AOC

- Spring AOP实现原理，为什么要使用AOP

  > - 底层原理：动态代理机制
  >
  > - 理解：AOP是动态代理的规范化，把动态代理的实现步骤、方式都定义好了，让开发人员使用一种统一的方式来使用动态代理。
  >
  > - 常见的切面功能有：事务，日志，统计信息，参数检查，权限验证
  >
  > - aop的常用注解
  >
  >   <img src="/Users/jackiez/学海/Java开发笔记/picture/image-20210713144053410.png" alt="image-20210713144053410" style="zoom:50%;" />
  >
  > - aop面向切面编程过程
  >
  >   > 1. 在分析项目功能时，找出切面
  >   > 2. 合理安排切面的执行时间（目标方法之前还是之后）
  >   > 3. 合理安排切面执行的位置（增强哪个类，哪个方法）
  >
  > - spring内部实现了aop规范，主要在事务处理时会用aop
  >
  > - aspectJ：项目开发经常用这个面向切面框架，spring框架中已经集成了aspectJ。

- Spring IOC原理以及**Bean**

  > - bean的生命周期
  >
  > - 依赖注入spring怎么做不同基本类型的注入的
  >
  > - beanfactory和factorybean的区别
  >
  > - Springboot是怎么去除xml的
  >
  > - 如何将第三方sdk的bean注入到容器中
  >
  > - 写一个 Controller，RESTful API，接受两个int 参数，返回相加结果，讲解涉及注解原理
  >
  > - spring循环依赖问题
  >
  >   > ![image-20210713162616623](/Users/jackiez/学海/Java开发笔记/picture/image-20210713162616623-6164778.png)
  >   >
  >   > ![image-20210713162736072](/Users/jackiez/学海/Java开发笔记/picture/image-20210713162736072-6164857.png)

- 注解

> - 注解原理：
>
>   ​		注解本质是一个继承了Annotation 的特殊接口，其具体实现类是Java 运行时生成的动态代理类。而我们通过反射获取注解时，返回的是Java 运行时生成的动态代理对象$Proxy1。通过代理对象调用自定义注解（接口）的方法，会最终调用AnnotationInvocationHandler 的invoke 方法。该方法会从memberValues 这个Map 中索引出对应的值。而memberValues 的来源是Java 常量池。
>
> - 四种元注解
>
>   @Documented – 注解是否将包含在JavaDoc中
>   @Retention – 什么时候使用该注解
>   @Target – 注解用于什么地方
>   @Inherited – 是否允许子类继承该注解

- 框架相关注解