- leetcode题型算法：

  > - 动态规划——排列组合问题（爬楼梯，零钱兑换），排列与组合的区别：外内循环与内外循环（不理解）
  >
  > - 递归：不要过多考虑细节，而是搞清楚关系和逻辑
  >
  > - Trie树（前缀树）
  >
  > - 前缀和
  >
  >   > - 将前缀和的值或者其相关变形 和 对应索引使用hashmap存储起来，通过map.containKey( )去寻找答案
  >   > - 必要时创建前缀和数组，有时可以用一个变量在循环中达到与前缀和数组一样的效果，节省空间。
  >
  > - 树的构建与遍历
  >
  >   > - 二叉树的构建：采用递归实现
  >   >
  >   >   ```java
  >   >   public void treeBuild(int[] arr) {
  >   >                 
  >   >       }
  >   >   ```
  >   >
  >   > 
  >   >
  >   > - 二叉树的先序遍历: 递归
  >   >
  >   >   ```java
  >   >   public void levelOrder(TreeNode root) {
  >   >           if(root==Null){
  >   >               return;
  >   >           }
  >   >           System.out.printf(root.val);
  >   >           levelOrder(root.left);
  >   >           levelOrder(root.right);
  >   >       }
  >   >   ```
  >   >
  >   > 
  >   >
  >   > - 二叉树的层序遍历: 利用队列结构存储每一层的节点，再出队列。
  >   >
  >   >   ```java
  >   >   Queue<TreeNode> queue = new LinkedList<>(){{ add(root); }};
  >   >   ArrayList<Integer> ans = new ArrayList<>();
  >   >   while(!queue.isEmpty()) {
  >   >     TreeNode node = queue.poll();
  >   >     ans.add(node.val);
  >   >     if(node.left != null) queue.add(node.left);
  >   >     if(node.right != null) queue.add(node.right);
  >   >   }
  >   >   ```
  >
  > - 各种排序（选择2，插入2，交换2，归并，基数）
  >
  >   > - 排序相关问题：
  >   >
  >   >   > - 为什么用快排而不用堆排序
  >   >   >
  >   >   >   > 1. 堆排序数据访问的方式没有快速排序友好
  >   >   >   > 2. 于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序
  >   >   >
  >   >   > - xxx。。。
  >
  >   ![f63727bfa7b67a6a120b03043dc95471](/Users/jackiez/学海/Java开发笔记/picture/f63727bfa7b67a6a120b03043dc95471-3912413.jpeg)
  >
  >   > - 快速排序（双指针），复杂度==O(nlogn)==，非稳定排序(**分析很重要**)
  >   >
  >   >   ```java
  >   >   public static void quickSort(int[] arr,int low,int high) {
  >   >     int left = low;
  >   >     int right = high;
  >   >     //temp就是基准位
  >   >     int temp = arr[low];
  >   >     if(low>high){
  >   >       return;
  >   >     }
  >   >     while (left<right) {
  >   >       //先看右边，依次往左递减
  >   >       while (temp<=arr[right]&&left<right) {
  >   >         right--;
  >   >       }
  >   >       //再看左边，依次往右递增
  >   >       while (temp>=arr[left]&&left<right) {
  >   >         left++;
  >   >       }
  >   >       //如果满足条件则交换
  >   >       if (left<right) {
  >   >         int t = arr[right];
  >   >         arr[right] = arr[left];
  >   >         arr[left] = t;
  >   >       }
  >   >     }
  >   >     //最后将基准为与left和right相等位置的数字交换
  >   >     arr[low] = arr[left];
  >   >     arr[left] = temp;
  >   >     //递归调用左半数组
  >   >     quickSort(arr, low, right-1);
  >   >     //递归调用右半数组
  >   >     quickSort(arr, right+1, high);
  >   >   }
  >   >   ```
  >   >
  >   > - 冒泡排序,复杂度==O(n^2)==，稳定排序
  >   >
  >   >   ```java
  >   >   public static void bubbleSort(int[] numbers){
  >   >     int size = numbers.length;
  >   >     for(int i = 0; i < size-1; i++){
  >   >       for(int j = 0;j < size-1-i; j++){
  >   >         if(numbers[j] > numbers[j+1]){  //交换两数位置
  >   >           int temp = numbers[j];
  >   >           numbers[j] = numbers[j+1];
  >   >           numbers[j+1] = temp;
  >   >         }
  >   >       }
  >   >     }
  >   >   }
  >   >   ```
  >   >
  >   > - 直接插入排序，复杂度==O(n^2)==，稳定排序(假设第一个数的位置正确,遍历后面的数并插入合适位置)
  >   >
  >   > - 希尔排序(基于插入排序的改进型插入排序算法)，详解：https://www.cnblogs.com/chengxiao/p/6104371.html
  >   >
  >   > - 直接选择排序(从数组中找到最小的值，与数组的第一个值互换，依次往后类推)，复杂度==O(n^2)==
  >   >
  >   >   ```java
  >   >   public static int[] selectSort(int[] nums){
  >   >       for (int i = 0; i < nums.length-1; i++) {
  >   >           int min = Integer.MAX_VALUE;
  >   >           int minIndex=0;
  >   >           for (int j = i; j < nums.length; j++) {
  >   >               if (nums[j] < min){
  >   >                   min = nums[j];
  >   >                   minIndex = j;
  >   >               }
  >   >           }
  >   >           int temp = nums[i];
  >   >           nums[i] = nums[minIndex];
  >   >           nums[minIndex] = temp;
  >   >       }
  >   >       return nums;
  >   >   }
  >   >   ```
  >   >
  >   > - 堆排序，详解：https://www.cnblogs.com/chengxiao/p/6129630.html
  >   >
  >   >   a.将无需序列构建成一个堆，根据升序降序需求选择大顶堆或小顶堆;
  >   >
  >   >   b.将堆顶元素与末尾元素交换，将最大元素"沉"到数组末端;
  >   >
  >   >   c.重新调整结构，使其满足堆定义，然后继续交换堆顶元素与当前末尾元素，反复执行调整+交换步骤，直到整个序列有序。
  >   >
  >   > - 归并排序：采用经典的**分治**策略,详解：https://www.cnblogs.com/chengxiao/p/6194356.html
  >   >
  >   >   ```java
  >   >   public static void sort(int[] arr){
  >   >     //在排序前，先建好一个长度等于原数组长度的临时数组，避免递归中频繁开辟空间
  >   >     int []temp = new int[arr.length];
  >   >     sort(arr,0,arr.length-1,temp);
  >   >   }
  >   >   private static void sort(int[] arr,int left,int right,int[] temp){
  >   >     if(left<right){
  >   >       int mid = (left+right)/2;
  >   >       sort(arr,left,mid,temp);//左边归并排序，使得左子序列有序
  >   >       sort(arr,mid+1,right,temp);//右边归并排序，使得右子序列有序
  >   >       merge(arr,left,mid,right,temp);//将两个有序子数组合并操作
  >   >     }
  >   >   }
  >   >   private static void merge(int[] arr,int left,int mid,int right,int[] temp){
  >   >     int i = left;//左序列指针
  >   >     int j = mid+1;//右序列指针
  >   >     int t = 0;//临时数组指针
  >   >     while (i<=mid && j<=right){
  >   >       if(arr[i]<=arr[j]){
  >   >         temp[t++] = arr[i++];
  >   >       }else {
  >   >         temp[t++] = arr[j++];
  >   >       }
  >   >     }
  >   >     while(i<=mid){//将左边剩余元素填充进temp中
  >   >       temp[t++] = arr[i++];
  >   >     }
  >   >     while(j<=right){//将右序列剩余元素填充进temp中
  >   >       temp[t++] = arr[j++];
  >   >     }
  >   >     t = 0;
  >   >     //将temp中的元素全部拷贝到原数组中
  >   >     while(left <= right){
  >   >       arr[left++] = temp[t++];
  >   >     }
  >   >   }
  >   >   ```
  >
  > - 有限状态自动机
  >
  > - 二分查找，二分法边界收缩问题(记住代码格式，套就完事儿了)
  >
  >   ```java
  >   //有时会用到递归，要领：将left，right这种边界条件作为递归函数的参数
  >   int left = 0;
  >   int right = n-1;
  >   while(left<right){
  >     int cur = (left+right)/2;
  >     if(cur满足条件1){
  >       left = cur + 1; 
  >     }else if(cur满足条件2){
  >       right = right - 1;
  >     }
  >   }
  >   ```
  >
  > 
  >
  > - 深度遍历(邻接矩阵、邻接表): 递归和回溯的思想，可行性剪枝（减少不必要的搜索）；深度和广度的代码结构
  >
  > - 数字的“位与”：n & n-1 特性分析（**n-1特性：n的最后一个1变零，其后面的所有位变1**）
  >
  >   ```java
  >   //求整数n二进制的1的个数
  >   public class Solution {
  >       public int hammingWeight(int n) {
  >           int res = 0;
  >           while(n != 0) {
  >               res++;
  >               n &= n - 1;
  >           }
  >           return res;
  >       }
  >   }
  >   ```
  >
  > 
  >
  > - 首尾双指针
  >
  > - hashmap
  >
  >   ```java
  >   //找出字符串s中第一个只出现过一次的字符
  >   class Solution {
  >       public char firstUniqChar(String s) {
  >           Map<Character,Boolean> map = new HashMap<>();
  >           for(int i=0;i<s.length();i++){
  >               if(map.containsKey(s.charAt(i))){
  >                   map.put(s.charAt(i),false);
  >               }else{
  >                   map.put(s.charAt(i),true);
  >               }
  >           }
  >           for(int i=0;i<s.length();i++){
  >               if(map.get(s.charAt(i))){
  >                   return s.charAt(i);
  >               }
  >           }
  >           return ' ';
  >       }
  >   }
  >   ```
  >
  > 
  >
  > - 堆（大顶堆，小顶堆）
  > - 栈——使用Deque接口的ArrayDeque实现栈的功能，ArrayDeque 可以作为栈来使用，效率要高于 Stack
  > - 栈、队列的实现（用栈实现队列，用队列实现栈）
  > - 生产者消费者模型（1.阻塞队列；2.lock）（避免虚假唤醒：解决方案就是把if判断改成while）
  > - LRU
  > - Trie树
  > - topK
  > - 字符串在文本中出现的次数 -> KMP

- 场景问题：

  > 1. 1G的数找中间一个数用什么排序？
  >
  >    找一次的话回考虑用快排，多次的话回考虑用平衡树维护，如果涉及到文件之间的分割和合并会考虑LCT
  >
  > 2. LRU原理
  >
  > 3. 一亿数找最小的前10个数，时间复杂度是多少？（快排，堆排，分治+Trie树/hash+小顶堆）
  >
  >    https://herobin.blog.csdn.net/article/details/96851395
  >
  > 4. 1G内存2G文件怎么[排序](https://www.nowcoder.com/jump/super-jump/word?word=排序)？
